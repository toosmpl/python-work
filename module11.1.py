import requests as rq
import pandas as pd
import numpy as np

# df = pd.read_csv('https://raw.githubusercontent.com/jorisvandenbossche/pandas-tutorial/master/data/titanic.csv')
# # Подключаемся к данным в ссылке
# print(type(df))  # Выводим тип данных (строки и колонны)
# print(df)  # Смотрим что на данные в строке конфигурации
# df2 = pd.DataFrame.from_dict({'a': [1, 2], 'b': [3, 4]})  # Создание дата фрейма из словарей внутри Пайтон
# # Ключ - название колонки, Значение - список всех значечий этой колонки
# df.to_csv('./tmp.csv')  # Запись данных из дата фрейма обратно в файлы или объекты Пайтон в локальную директорию в
# # формате csv
# df.info()  # Вызов общей информации о текущем Дата фрейме, количество записей, строк, колонок, описание колонок, название
# # и тип данных к которому они относятся (формат str определяется как object)

# # username:corey, password:testing
# r = rq.get('https://httpbin.org/basic-auth/corey/testing', auth=('corey', 'testing'))
# # В первом варианте открываем ссылку авторизации по логину и паролю, при верных параметрах в строке конфига
# # выдает True и имя пользователя, Response [200](страница открылась)
# print(r.text)
# print(r)
#
# # r = rq.get('https://httpbin.org/basic-auth/corey/testing', auth=('correy', 'testing'))
# # # Во втором варианте авторизация не проходит, так как указаны не верные данные
# # # В этом случае в строке конфигурации ничего не отображается, Response [401](ошибка)
# # print(r.text)

# r = rq.get('https://httpbin.org/delay/1', timeout=3)
# # Открываем ссылку с задержкой 1 секунда и устанавливаем таймаут на время 3 секунды
# # ссылка успешно открывается
# r = rq.get('https://httpbin.org/delay/6', timeout=3)
# #Открываем ссылку с задержкой 6 секунд и устанавливаем таймаут на время 3 секунды
# # ссылка не открывается так как срабатывает таймаут
# print(r)

# r = rq.get('https://imgs.xkcd.com/comics/python.png')
#
# with open('comic.png','wb') as f:
#     f.write(r.content)
# # Данный алгоритм скачивает картинку с ссылки к нам на компьютер и сохраняет ее
# a = np.zeros(3)  # создание 3 массивов 0 (тип float)
# a = np.zeros(3, dtype=int)  # создание 3 массивов 0 (тип int)
# print(a)
# z = np.empty(3)  # создание пустых 3 пустых массивов которые можно заполнить
# print(z)
# z = np.zeros(10)
# print(z.shape) #просмотр размера массива
# z.shape = (10, 1) #изменение размера массива
# print(z)
# z = np.linspace(2, 10, 6) # создание (равного) радиуса от, до, количество элементов
# print(z)
# z = np.array([10, 20]) #еще один способ создание массива со своими элементами внутри
# print(z)
# a_list = [1, 2, 3, 4, 5, 6, 7]
# z = np.array([a_list]) #помещение массива внутрь другого массива
# print(z)
# b_list = [[1, 2, 3, 4, 5], [5, 6, 7, 8, 9]]
# z = np.array([b_list]) #список состоящий из массива с двумя индексами выносится в разные строчки и также помещается
# # # внутрь массива np.array
# # print(z)
# help(z) #вывод всей информации об объекте
# так же при помощи библиотеки skimage пакета io
# photo = io.imread('название файла.jpg') при запросе типа выдаст numpy.ndarray
# следовательно можно измерить цветовой формат картинки и его размер командой photo.shape
# z = np.array([1, 2, 3, 4, 5])
# print(z > 3) #вывод что истина, а что нет (каждый элемент внутри массива)
# print(z[z > 3]) #вывод значение внутри массива соответсвующих условию
# a_array = np.array([1, 2, 3, 4, 5])
# b_array = np.array([6, 7, 8, 9, 10])
# print(a_array + b_array) #складывание двух массивов (каждый эллемент складвается с другим под тем же индексом)
# # если написать a_array + *число* то это число прибавится к каждому числу внутри массива
# # все это работает так с умножением
# print(a_array @ b_array) # перемножение одинаковых индексов внутри массива и их общая сумма
# # np.sort(переменная) сортирует элементы по порядку